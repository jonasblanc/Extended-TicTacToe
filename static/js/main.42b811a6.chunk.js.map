{"version":3,"sources":["utilities.js","components/GameCell/index.js","components/Grid/index.js","components/GameSettings/index.js","components/Game/arrayUtilities.js","components/Game/IA/defensive.js","components/Game/IA/random.js","components/Game/index.js","components/Game/IA/index.js","App.js","reportWebVitals.js","index.js"],"names":["range","start","end","ans","i","push","GameCell","props","useEffect","value","className","onClick","actionClick","Grid","r","side","map","y","j","index","array","handleClick","returnArray","GameSettings","useState","minSide","maxSide","setSide","players","firstPlayer","setFirstPlayer","onSubmit","event","preventDefault","handleSubmit","onChange","newSide","target","x","newFirst","type","isInBound","getElem","alert","Number","hasRightDownDiagOfLength","length","countRightDownDiagOfLength","count","symbol","it","hasLeftDownDiagOfLength","countLeftDownDiagOfLength","hasRightLineOfLength","countRightLineOfLength","hasDownColumnOfLength","countDownColumnOfLength","OWN_ALIGNMENT","ADV_ALIGNMENT","debugAlert","message","defense","grid","ownSymbol","total","hasUnBoundedAlignment","hasOneBoundedAlignment","checkPredict","result","Math","floor","random","predicates","max","min","isCheckingOwnCombi","next_pos","l","p","__hasUnBoundedAlignment__","alignments","numberOfUnboundedSide","alignmentIdx","size","hasFirstBound","isFirstBounded","sizeOfSecondBoundedAlignment","lengthBeforeSecondBound","hasSecondBound","potentialPlaceForSecondBound","bounds","computeBounds","i_1","j_1","i_2","j_2","Error","alignmentNumber","placeForSecondBound","elem","Game","Array","fill","setArray","isCrossNext","setIsCrossNext","status","setStatus","isFinish","setIsFinish","round","setRound","handlePlay","newArray","slice","setAndReturnWinner","winner","lengthToWin","calculateWinner","setUpAndPlay","pos","nextMoveIA","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.42b811a6.chunk.js","sourcesContent":["export function range(start, end) {\n  var ans = [];\n  for (let i = start; i <= end; i++) {\n    ans.push(i);\n  }\n  return ans;\n}\n","import React, { useEffect } from \"react\";\nimport \"./style.css\";\n\nexport default function GameCell(props) {\n    useEffect(() => {}, [props.value]);\n    return (\n        <button\n            className=\"square\"\n            onClick={() => {\n                props.actionClick();\n            }}\n        >\n            {props.value}\n        </button>\n    );\n}\n","import React from \"react\";\n\nimport \"./style.css\";\nimport { range } from \"../../utilities\";\n\nimport GameCell from \"../GameCell\";\n\nexport default function Grid(props) {\n    const renderCell = (j) => {\n        return (\n            <GameCell\n                key={\"GRID_NUM_\" + j}\n                index={j}\n                value={props.array[j]}\n                actionClick={() => props.handleClick(j)}\n            />\n        );\n    };\n\n    const returnArray = () => {\n        const r = range(0, props.side - 1);\n        return r.map((i) => (\n            <div key={\"ROW_NUM_\" + i} className=\"grid-row\">\n                {r.map((y) => renderCell(i * props.side + y))}\n            </div>\n        ));\n    };\n\n    return <div>{returnArray(3)}</div>;\n}\n","import React, { useState } from \"react\";\nimport \"./style.css\";\n\nimport { range } from \"../../utilities\";\n\nexport default function GameSettings(props) {\n    const [side, setSide] = useState((props.minSide + props.maxSide) / 2);\n    const [players, setPlayers] = useState([\"X\", \"O\"]);\n    const [firstPlayer, setFirstPlayer] = useState(players[0]);\n\n    const optionListSide = (min, max) => {\n        return (\n            <select value={side} onChange={(newSide) => setSide(newSide.target.value)}>\n                {range(props.minSide, props.maxSide).map((x) => (\n                    <option key={\"SIDE_NUM_\" + x} value={x}>\n                        {x}\n                    </option>\n                ))}\n            </select>\n        );\n    };\n\n    const optionFirstPlayer = () => {\n        return (\n            <select\n                value={firstPlayer}\n                onChange={(newFirst) => setFirstPlayer(newFirst.target.value)}\n            >\n                {players.map((x) => (\n                    <option key={\"PLAYER_\" + x} value={x}>\n                        {x}\n                    </option>\n                ))}\n            </select>\n        );\n    };\n\n    const handleSubmit = (event) => {\n        event.preventDefault();\n        props.handleSubmit(side, firstPlayer);\n    };\n\n    return (\n        <form onSubmit={handleSubmit} className=\"vertical-form\">\n            <label>\n                Select the width of the grid:\n                {optionListSide(props.minSide, props.maxSide)}\n            </label>\n            <label>\n                Select the first player:\n                {optionFirstPlayer()}\n            </label>\n            <input type=\"submit\" value=\"Start\" />\n        </form>\n    );\n}\n","function isInBound(side, i, j) {\n    if (0 <= i && i < side && 0 <= j && j < side) {\n        return true;\n    }\n    return false;\n}\n\nfunction getElem(array, side, i, j) {\n    if (!isInBound(side, i, j)) {\n        alert(\"index out of bound\");\n    }\n    return array[Number(i * side) + Number(j)];\n}\n\nfunction hasRightDownDiagOfLength(array, side, i, j, length) {\n    if (countRightDownDiagOfLength(array, side, i, j, length) === length) {\n        return getElem(array, side, i, j);\n    }\n    return null;\n}\n\nfunction countRightDownDiagOfLength(array, side, i, j, length) {\n    let count = 0;\n\n    if (i <= side - length && j <= side - length && i >= 0 && j >= 0) {\n        let symbol = getElem(array, side, i, j);\n        if (symbol != null) {\n            count = 1;\n            for (let it = 1; it < length; it++) {\n                const elem = getElem(array, side, i + it, j + it);\n                if (elem === symbol) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nfunction hasLeftDownDiagOfLength(array, side, i, j, length) {\n    if (countLeftDownDiagOfLength(array, side, i, j, length) === length) {\n        return getElem(array, side, i, j);\n    }\n    return null;\n}\n\nfunction countLeftDownDiagOfLength(array, side, i, j, length) {\n    let count = 0;\n    if (i <= side - length && j < side && i >= 0 && j >= length - 1) {\n        let symbol = getElem(array, side, i, j);\n        if (symbol != null) {\n            count = 1;\n            for (let it = 1; it < length; it++) {\n                const elem = getElem(array, side, i + it, j - it);\n                if (elem === symbol) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nfunction hasRightLineOfLength(array, side, i, j, length) {\n    if (countRightLineOfLength(array, side, i, j, length) === length) {\n        return getElem(array, side, i, j);\n    }\n    return null;\n}\nfunction countRightLineOfLength(array, side, i, j, length) {\n    let count = 0;\n    if (i < side && j <= side - length && i >= 0 && j >= 0) {\n        let symbol = getElem(array, side, i, j);\n        if (symbol != null) {\n            count = 1;\n            for (let it = 1; it < length; it++) {\n                const elem = getElem(array, side, i, j + it);\n                if (elem === symbol) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nfunction hasDownColumnOfLength(array, side, i, j, length) {\n    if (countDownColumnOfLength(array, side, i, j, length) === length) {\n        return getElem(array, side, i, j);\n    }\n    return null;\n}\n\nfunction countDownColumnOfLength(array, side, i, j, length) {\n    let count = 0;\n    if (i <= side - length && j < side && i >= 0 && j >= 0) {\n        let symbol = getElem(array, side, i, j);\n        if (symbol != null) {\n            count = 1;\n            for (let it = 1; it < length; it++) {\n                const elem = getElem(array, side, i + it, j);\n                if (elem === symbol) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nexport {\n    isInBound,\n    getElem,\n    countRightDownDiagOfLength,\n    countLeftDownDiagOfLength,\n    countDownColumnOfLength,\n    countRightLineOfLength,\n};\n\nfunction calculateWinner(array, side, lengthToWin) {\n    const predicates = [\n        hasRightDownDiagOfLength,\n        hasLeftDownDiagOfLength,\n        hasDownColumnOfLength,\n        hasRightLineOfLength,\n    ];\n    for (let i = 0; i < side; ++i) {\n        for (let j = 0; j < side; ++j) {\n            for (let p = 0; p < predicates.length; ++p) {\n                const symbol = predicates[p](array, side, i, j, lengthToWin);\n                if (symbol != null) {\n                    return symbol;\n                }\n            }\n        }\n    }\n    return null;\n}\n\nexport { calculateWinner };\n","import {\n    isInBound,\n    getElem,\n    countRightDownDiagOfLength,\n    countLeftDownDiagOfLength,\n    countDownColumnOfLength,\n    countRightLineOfLength,\n} from \"../arrayUtilities\";\n\nimport { random } from \"./random\";\n\nconst WINNING_LENGTH = 5;\nconst OWN_ALIGNMENT = true;\nconst ADV_ALIGNMENT = false;\nconst ONE_BOUNDED = 1;\nconst UNBOUNDED = 2;\n\nconst DEBUG = false;\n\nfunction debugAlert(message) {\n    if (DEBUG) {\n        alert(message);\n    }\n}\nexport default function defense(grid, side, ownSymbol) {\n    const total = [hasUnBoundedAlignment, hasOneBoundedAlignment];\n\n    // IA has alignment of 4 and we can align a other one => win\n    var r = checkPredict(total, 4, 4, grid, side, ownSymbol, OWN_ALIGNMENT);\n    if (r !== -1) {\n        debugAlert(\"0\");\n        return r;\n    }\n\n    // Adversary has alignment of 4\n    r = checkPredict(total, 4, 4, grid, side, ownSymbol, ADV_ALIGNMENT);\n    if (r !== -1) {\n        debugAlert(\"1\");\n        return r;\n    }\n\n    // IA has alignment of 3 unbounded\n    r = checkPredict([hasUnBoundedAlignment], 3, 3, grid, side, ownSymbol, OWN_ALIGNMENT);\n    if (r !== -1) {\n        debugAlert(\"2\");\n        return r;\n    }\n\n    // Adversary has alignment of 3 unbounded\n    r = checkPredict([hasUnBoundedAlignment], 4, 3, grid, side, ownSymbol, ADV_ALIGNMENT);\n    if (r !== -1) {\n        debugAlert(\"3\");\n        return r;\n    }\n\n    // No vital move need\n\n    // Adversary has alignment of 3  or 2 bounded or one bounded\n    r = checkPredict(total, 3, 2, grid, side, ownSymbol, ADV_ALIGNMENT);\n    if (r !== -1) {\n        debugAlert(\"4\");\n        return r;\n    }\n\n    // IA has alignment of 3 , 2 or 1\n    r = checkPredict(total, 3, 1, grid, side, ownSymbol, OWN_ALIGNMENT);\n    if (r !== -1) {\n        debugAlert(\"5\");\n        return r;\n    }\n    //alert(\"random\");\n    return random(grid, side);\n}\n\n/**\n * Check every given predicates sort by priority order over all grid for a given range of lengths\n * @param {*} predicates\n * @param {*} max - Max length\n * @param {*} min - Min length\n * @param {*} grid\n * @param {*} side\n * @param {*} ownSymbol\n * @param {*} isCheckingOwnCombi - true if searching for own alignment\n *\n * @return a position aligned with the alignment that fullfilled a predicate\n */\nfunction checkPredict(predicates, max, min, grid, side, ownSymbol, isCheckingOwnCombi) {\n    let next_pos = 0;\n\n    for (let l = max; l >= min; --l) {\n        for (let p = 0; p < predicates.length; ++p) {\n            for (let i = 0; i < side; ++i) {\n                for (let j = 0; j < side; ++j) {\n                    next_pos = predicates[p](grid, side, i, j, ownSymbol, l, isCheckingOwnCombi);\n                    if (next_pos !== -1) {\n                        return next_pos;\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n}\n\n/**\n * Check if there is a one-bounded alignemnt start at (i,j) of given length\n * @param {*} array\n * @param {*} side\n * @param {*} i\n * @param {*} j\n * @param {*} ownSymbol\n * @param {*} length\n * @param {*} isCheckingOwnCombi - true if searching for own alignment\n */\nfunction hasOneBoundedAlignment(array, side, i, j, ownSymbol, length, isCheckingOwnCombi) {\n    return __hasUnBoundedAlignment__(\n        array,\n        side,\n        i,\n        j,\n        ownSymbol,\n        length,\n        isCheckingOwnCombi,\n        ONE_BOUNDED\n    );\n}\n\nconst alignments = [\n    countRightDownDiagOfLength,\n    countLeftDownDiagOfLength,\n    countDownColumnOfLength,\n    countRightLineOfLength,\n];\n\n/**\n * Check if there is a unbounded alignemnt start at (i,j) of given length\n * @param {*} array\n * @param {*} side\n * @param {*} i\n * @param {*} j\n * @param {*} ownSymbol\n * @param {*} length\n * @param {*} isCheckingOwnCombi - true if searching for own alignment\n */\nfunction hasUnBoundedAlignment(array, side, i, j, ownSymbol, length, isCheckingOwnCombi) {\n    return __hasUnBoundedAlignment__(\n        array,\n        side,\n        i,\n        j,\n        ownSymbol,\n        length,\n        isCheckingOwnCombi,\n        UNBOUNDED\n    );\n}\n\n// Helper function for hasOneBoundedCombin and hasUnBoundedCombin\nfunction __hasUnBoundedAlignment__(\n    array,\n    side,\n    i,\n    j,\n    ownSymbol,\n    length,\n    isCheckingOwnCombi,\n    numberOfUnboundedSide\n) {\n    const FIRST_BOUND = 0;\n    const SECOND_BOUND = 1;\n\n    for (let alignmentIdx = 0; alignmentIdx < alignments.length; ++alignmentIdx) {\n        // Compute number of aligned symbols starting at pos (i,j)\n        const size = alignments[alignmentIdx](array, side, i, j, WINNING_LENGTH);\n\n        // If it is currently checking for this number of symbols\n        var symbol = null;\n        if (size === length) {\n            symbol = getElem(array, side, i, j);\n        }\n\n        // If symbol match what we are currently looking for\n        if (\n            symbol != null &&\n            ((symbol !== ownSymbol && !isCheckingOwnCombi) ||\n                (symbol === ownSymbol && isCheckingOwnCombi))\n        ) {\n            const hasFirstBound = isFirstBounded(array, side, i, j, alignmentIdx);\n            const sizeOfSecondBoundedAlignment = lengthBeforeSecondBound(\n                array,\n                side,\n                i,\n                j,\n                alignmentIdx\n            );\n            const hasSecondBound = sizeOfSecondBoundedAlignment > 0;\n            const potentialPlaceForSecondBound = -sizeOfSecondBoundedAlignment;\n\n            if (size === 3) {\n                debugAlert(\n                    hasSecondBound +\n                        \" - hasSecondBound \" +\n                        potentialPlaceForSecondBound +\n                        \" - potentialPlaceForSecondBound\"\n                );\n            }\n\n            const bounds = computeBounds(\n                i,\n                j,\n                hasSecondBound ? sizeOfSecondBoundedAlignment : potentialPlaceForSecondBound\n            );\n            const i_1 = bounds[alignmentIdx][FIRST_BOUND][0];\n            const j_1 = bounds[alignmentIdx][FIRST_BOUND][1];\n\n            switch (numberOfUnboundedSide) {\n                case UNBOUNDED:\n                    if (!hasFirstBound && !hasSecondBound) {\n                        if (potentialPlaceForSecondBound > 0) {\n                            const i_2 = bounds[alignmentIdx][SECOND_BOUND][0];\n                            const j_2 = bounds[alignmentIdx][SECOND_BOUND][1];\n                            debugAlert(\"no second bound: \" + i_2 + \" \" + j_2);\n                            return Number(i_2 * side) + Number(j_2);\n                        } else {\n                            debugAlert(\"unbounded: \" + i_1 + \" \" + j_1);\n                            return Number(i_1 * side) + Number(j_1);\n                        }\n                    }\n                    break;\n                case ONE_BOUNDED:\n                    if (!hasSecondBound && potentialPlaceForSecondBound > 0) {\n                        const i_2 = bounds[alignmentIdx][SECOND_BOUND][0];\n                        const j_2 = bounds[alignmentIdx][SECOND_BOUND][1];\n                        debugAlert(\"no second bound: \" + i_2 + \" \" + j_2);\n                        return Number(i_2 * side) + Number(j_2);\n                    }\n                    if (!hasFirstBound) {\n                        debugAlert(\"no first bound: \" + i_1 + \" \" + j_1);\n\n                        return Number(i_1 * side) + Number(j_1);\n                    }\n                    break;\n                default:\n                    return new Error(\n                        \"Bad parameter: numberOfUnboundedSide \" +\n                            numberOfUnboundedSide +\n                            \" should be 1 or 2\"\n                    );\n            }\n        }\n    }\n\n    return -1;\n}\n\nfunction isFirstBounded(grid, side, i, j, alignmentNumber) {\n    const bounds = computeBounds(i, j, 0); // Length doesn't matter for first bound\n    const i_1 = bounds[alignmentNumber][0][0];\n    const j_1 = bounds[alignmentNumber][0][1];\n    if (!isInBound(side, i_1, j_1)) {\n        return true;\n    }\n    const elem = getElem(grid, side, i_1, j_1);\n    return elem != null;\n}\n\nfunction lengthBeforeSecondBound(grid, side, i, j, alignmentNumber) {\n    var placeForSecondBound = 0;\n    for (let length = 1; length < WINNING_LENGTH; length++) {\n        const bounds = computeBounds(i, j, length);\n        const i_2 = bounds[alignmentNumber][1][0];\n        const j_2 = bounds[alignmentNumber][1][1];\n        if (!isInBound(side, i_2, j_2)) {\n            return length;\n        }\n        const elem = getElem(grid, side, i_2, j_2);\n        if (elem !== null && elem !== getElem(grid, side, i, j)) {\n            return length;\n        } else {\n            if (elem === null && placeForSecondBound === 0) {\n                placeForSecondBound = length;\n            }\n        }\n    }\n    return -placeForSecondBound;\n}\n\nfunction computeBounds(i, j, length) {\n    const tab = [\n        [\n            // Right down diag\n            [[i - 1], [j - 1]],\n            [[i + length], [j + length]],\n        ],\n        [\n            // Left down diag\n            [[i - 1], [j + 1]],\n            [[i + length], [j - length]],\n        ],\n        [\n            // Down column\n            [[i - 1], [j]],\n            [[i + length], [j]],\n        ],\n        [\n            // Right line\n            [[i], [j - 1]],\n            [[i], [j + length]],\n        ],\n    ];\n    return tab;\n}\n","export function random(grid, side) {\n  let i = 0;\n  let j = 0;\n  let result = 0;\n  do {\n    i = Math.floor(Math.random() * (side - 1));\n    j = Math.floor(Math.random() * (side - 1));\n    result = Number(i * side) + Number(j);\n  } while (grid[result] != null);\n\n  return result;\n}\n","import React, { useEffect, useState } from \"react\";\nimport \"./style.css\";\n\nimport Grid from \"../Grid\";\nimport GameSettings from \"../GameSettings\";\nimport nextMoveIA from \"./IA\";\nimport { calculateWinner } from \"./arrayUtilities\";\nexport default function Game() {\n    const MIN_SIDE = 5;\n    const MAX_SIDE = 25;\n\n    const [side, setSide] = useState(15);\n    const [array, setArray] = useState(Array((side - 1) * (side - 1)).fill(null));\n\n    const [isCrossNext, setIsCrossNext] = useState(false);\n    const [status, setStatus] = useState(\"Press start to play !\");\n    const [isFinish, setIsFinish] = useState(true);\n\n    const [round, setRound] = useState(0);\n\n    const handleClick = (i) => {\n        if (!isFinish && array[i] == null) {\n            handlePlay(i);\n        } else {\n            //alert(\"Please choose an empty cell - \" + array[i]);\n        }\n    };\n\n    const handlePlay = (i) => {\n        const newArray = array.slice();\n        newArray[i] = isCrossNext ? \"X\" : \"O\";\n        setArray(newArray);\n        setIsCrossNext(!isCrossNext);\n        setRound(round + 1);\n    };\n\n    const handleSubmit = (side, firstPlayer) => {\n        setIsCrossNext(firstPlayer === \"X\");\n        const grid = Array((side - 1) * (side - 1)).fill(null);\n        setArray(grid);\n        setIsFinish(false);\n        setSide(side);\n        setRound(0);\n    };\n\n    const setAndReturnWinner = () => {\n        const winner = calculateWinner(array, side, 5);\n        if (winner != null) {\n            setStatus(\"Winner is \" + winner + \" !\");\n            setIsFinish(true);\n            return winner;\n        }\n        return winner;\n    };\n\n    const setUpAndPlay = () => {\n        setStatus(\"Next player is \" + (isCrossNext ? \"X\" : \"O\"));\n        if (!isCrossNext) {\n            //alert(\"Round: \" + round);\n            const pos = nextMoveIA(array, side, \"O\");\n            handleClick(pos);\n        }\n    };\n\n    useEffect(() => {\n        if (!isFinish) {\n            if (setAndReturnWinner() == null) {\n                setUpAndPlay();\n                //alert(\"refresh\" + round);\n            }\n        }\n    });\n\n    return (\n        <div className=\"game-container\">\n            <div className=\"settings-container\">\n                <GameSettings handleSubmit={handleSubmit} minSide={MIN_SIDE} maxSide={MAX_SIDE} />\n            </div>\n            <div className=\"grid-container\">\n                {status}\n                <Grid array={array} side={side} handleClick={handleClick} />\n            </div>\n            <div className=\"text-container\">\n                {\"Rules:\"}\n                <br></br>\n                {\"Be the first one to align 5 symbols\"}\n                <br></br>\n                <br></br>\n                {\"Context:\"}\n                <br></br>\n                {\n                    \"This was my favorite game to keep me busy during boring class in high school. Hey kids, don't be like me, be focused at school, it's important. \"\n                }\n            </div>\n        </div>\n    );\n}\n","import defense from \"./defensive\";\n\nexport default function nextMoveIA(grid, side, ownSymbol) {\n  //alert(\"What's my next move ?\");\n  return defense(grid, side, ownSymbol);\n}\n","import \"./App.css\";\nimport Game from \"./components/Game\";\n\nfunction App() {\n    return (\n        <div className=\"App\">\n            <header className=\"App-header\">\n                <Game />\n            </header>\n        </div>\n    );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}