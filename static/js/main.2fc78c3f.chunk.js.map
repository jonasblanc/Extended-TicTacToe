{"version":3,"sources":["utilities.js","components/GameCell/index.js","components/Grid/index.js","components/GameSettings/index.js","components/Game/arrayUtilities.js","components/Game/IA/smartBob.js","components/Game/IA/random.js","components/Game/index.js","components/Game/IA/index.js","App.js","reportWebVitals.js","index.js"],"names":["range","start","end","ans","i","push","GameCell","props","useEffect","value","className","onClick","actionClick","Grid","r","side","map","y","j","index","array","handleClick","returnArray","GameSettings","useState","minSide","maxSide","setSide","players","firstPlayer","setFirstPlayer","onSubmit","event","preventDefault","handleSubmit","onChange","newSide","target","x","newFirst","type","isInBound","getElem","grid","Error","Number","countRightDownDiagOfLength","length","count","symbol","it","countLeftDownDiagOfLength","countRightLineOfLength","countDownColumnOfLength","hasRightDownDiagOfLength","hasLeftDownDiagOfLength","hasRightLineOfLength","hasDownColumnOfLength","OWN_ALIGNMENT","ADV_ALIGNMENT","debugAlert","message","smartBobNextMove","ownSymbol","total","hasUnBoundedAlignment","hasOneBoundedAlignment","checkPredict","result","Math","floor","random","predicates","max","min","isCheckingOwnCombi","next_pos","l","p","__hasUnBoundedAlignment__","countFunctionArray","numberOfUnboundedSide","alignIdx","hasFirstBound","isFirstBounded","sizeSecondBound","lengthBeforeSecondBound","hasSecondBound","sizePotSecBound","lengthSecBound","posFirstBound","computeBoundPos","posSecBound","alignmentNumber","bounds","computeBounds","i_1","j_1","placeForSecondBound","i_2","j_2","elem","boundNumber","Game","Array","fill","setArray","isCrossNext","setIsCrossNext","status","setStatus","isFinish","setIsFinish","newArray","slice","playRound","winner","lengthToWin","calculateWinner","pos","nextMoveIA","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2fc78c3f.chunk.js","sourcesContent":["export function range(start, end) {\n  var ans = [];\n  for (let i = start; i <= end; i++) {\n    ans.push(i);\n  }\n  return ans;\n}\n","import React, { useEffect } from \"react\";\nimport \"./style.css\";\n\nexport default function GameCell(props) {\n    useEffect(() => {}, [props.value]);\n    return (\n        <button\n            className=\"square\"\n            onClick={() => {\n                props.actionClick();\n            }}\n        >\n            {props.value}\n        </button>\n    );\n}\n","import React from \"react\";\n\nimport \"./style.css\";\nimport { range } from \"../../utilities\";\n\nimport GameCell from \"../GameCell\";\n\nexport default function Grid(props) {\n    const renderCell = (j) => {\n        return (\n            <GameCell\n                key={\"GRID_NUM_\" + j}\n                index={j}\n                value={props.array[j]}\n                actionClick={() => props.handleClick(j)}\n            />\n        );\n    };\n\n    const returnArray = () => {\n        const r = range(0, props.side - 1);\n        return r.map((i) => (\n            <div key={\"ROW_NUM_\" + i} className=\"grid-row\">\n                {r.map((y) => renderCell(i * props.side + y))}\n            </div>\n        ));\n    };\n\n    return <div>{returnArray(3)}</div>;\n}\n","import React, { useState } from \"react\";\nimport \"./style.css\";\n\nimport { range } from \"../../utilities\";\n\nexport default function GameSettings(props) {\n    const [side, setSide] = useState((props.minSide + props.maxSide) / 2);\n    const [players, setPlayers] = useState([\"X\", \"O\"]);\n    const [firstPlayer, setFirstPlayer] = useState(players[0]);\n\n    const optionListSide = (min, max) => {\n        return (\n            <select value={side} onChange={(newSide) => setSide(newSide.target.value)}>\n                {range(props.minSide, props.maxSide).map((x) => (\n                    <option key={\"SIDE_NUM_\" + x} value={x}>\n                        {x}\n                    </option>\n                ))}\n            </select>\n        );\n    };\n\n    const optionFirstPlayer = () => {\n        return (\n            <select\n                value={firstPlayer}\n                onChange={(newFirst) => setFirstPlayer(newFirst.target.value)}\n            >\n                {players.map((x) => (\n                    <option key={\"PLAYER_\" + x} value={x}>\n                        {x}\n                    </option>\n                ))}\n            </select>\n        );\n    };\n\n    const handleSubmit = (event) => {\n        event.preventDefault();\n        props.handleSubmit(side, firstPlayer);\n    };\n\n    return (\n        <form onSubmit={handleSubmit} className=\"vertical-form\">\n            <label>\n                Select the width of the grid:\n                {optionListSide(props.minSide, props.maxSide)}\n            </label>\n            <label>\n                Select the first player:\n                {optionFirstPlayer()}\n            </label>\n            <input type=\"submit\" value=\"Start\" />\n        </form>\n    );\n}\n","/**\n * Return true if (i,j) is a valid position in the game grid\n * @param {*} side\n * @param {*} i\n * @param {*} j\n */\nfunction isInBound(side, i, j) {\n    if (0 <= i && i < side && 0 <= j && j < side) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * Return the element at position (i,j)\n * @param {*} grid\n * @param {*} side\n * @param {*} i\n * @param {*} j\n *\n */\nfunction getElem(grid, side, i, j) {\n    if (!isInBound(side, i, j)) {\n        throw new Error(\"Index out of bound\");\n    }\n    return grid[Number(i * side) + Number(j)];\n}\n\n//========================================== Count symbol for different alignments ==========================================//\n\n/**\n * If symbol (i,j) is not null, count the number of same symbol on the down right diagonal of given length starting at (i,j)\n * @param {*} grid\n * @param {*} side\n * @param {*} i\n * @param {*} j\n * @param {*} length\n */\nfunction countRightDownDiagOfLength(grid, side, i, j, length) {\n    let count = 0;\n\n    if (i <= side - length && j <= side - length && i >= 0 && j >= 0) {\n        let symbol = getElem(grid, side, i, j);\n        if (symbol != null) {\n            count = 1;\n            for (let it = 1; it < length; it++) {\n                const elem = getElem(grid, side, i + it, j + it);\n                if (elem === symbol) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n/**\n * If symbol (i,j) is not null, count the number of same symbol on the left right diagonal of given length starting at (i,j)\n * @param {*} grid\n * @param {*} side\n * @param {*} i\n * @param {*} j\n * @param {*} length\n */\nfunction countLeftDownDiagOfLength(grid, side, i, j, length) {\n    let count = 0;\n    if (i <= side - length && j < side && i >= 0 && j >= length - 1) {\n        let symbol = getElem(grid, side, i, j);\n        if (symbol != null) {\n            count = 1;\n            for (let it = 1; it < length; it++) {\n                const elem = getElem(grid, side, i + it, j - it);\n                if (elem === symbol) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n/**\n * If symbol (i,j) is not null, count the number of same symbol on line of given length going to the right starting at (i,j)\n * @param {*} grid\n * @param {*} side\n * @param {*} i\n * @param {*} j\n * @param {*} length\n */\nfunction countRightLineOfLength(grid, side, i, j, length) {\n    let count = 0;\n    if (i < side && j <= side - length && i >= 0 && j >= 0) {\n        let symbol = getElem(grid, side, i, j);\n        if (symbol != null) {\n            count = 1;\n            for (let it = 1; it < length; it++) {\n                const elem = getElem(grid, side, i, j + it);\n                if (elem === symbol) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n/**\n * If symbol (i,j) is not null, count the number of same symbol on column of given length going down starting at (i,j)\n * @param {*} grid\n * @param {*} side\n * @param {*} i\n * @param {*} j\n * @param {*} length\n */\nfunction countDownColumnOfLength(grid, side, i, j, length) {\n    let count = 0;\n    if (i <= side - length && j < side && i >= 0 && j >= 0) {\n        let symbol = getElem(grid, side, i, j);\n        if (symbol != null) {\n            count = 1;\n            for (let it = 1; it < length; it++) {\n                const elem = getElem(grid, side, i + it, j);\n                if (elem === symbol) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nexport {\n    isInBound,\n    getElem,\n    countRightDownDiagOfLength,\n    countLeftDownDiagOfLength,\n    countDownColumnOfLength,\n    countRightLineOfLength,\n};\n\n//========================================== Helpers for calculateWinner ==========================================//\n\nfunction hasRightDownDiagOfLength(grid, side, i, j, length) {\n    if (countRightDownDiagOfLength(grid, side, i, j, length) === length) {\n        return getElem(grid, side, i, j);\n    }\n    return null;\n}\n\nfunction hasLeftDownDiagOfLength(grid, side, i, j, length) {\n    if (countLeftDownDiagOfLength(grid, side, i, j, length) === length) {\n        return getElem(grid, side, i, j);\n    }\n    return null;\n}\n\nfunction hasRightLineOfLength(grid, side, i, j, length) {\n    if (countRightLineOfLength(grid, side, i, j, length) === length) {\n        return getElem(grid, side, i, j);\n    }\n    return null;\n}\n\nfunction hasDownColumnOfLength(grid, side, i, j, length) {\n    if (countDownColumnOfLength(grid, side, i, j, length) === length) {\n        return getElem(grid, side, i, j);\n    }\n    return null;\n}\n\n//========================================== calculateWinner ==========================================//\n\n/**\n * Return the winner's symbol or null if there is no winner\n * @param {*} grid\n * @param {*} side\n * @param {*} lengthToWin\n */\nfunction calculateWinner(grid, side, lengthToWin) {\n    const predicates = [\n        hasRightDownDiagOfLength,\n        hasLeftDownDiagOfLength,\n        hasDownColumnOfLength,\n        hasRightLineOfLength,\n    ];\n    for (let i = 0; i < side; ++i) {\n        for (let j = 0; j < side; ++j) {\n            for (let p = 0; p < predicates.length; ++p) {\n                const symbol = predicates[p](grid, side, i, j, lengthToWin);\n                if (symbol != null) {\n                    return symbol;\n                }\n            }\n        }\n    }\n    return null;\n}\n\nexport { calculateWinner };\n","import {\n    isInBound,\n    getElem,\n    countRightDownDiagOfLength,\n    countLeftDownDiagOfLength,\n    countDownColumnOfLength,\n    countRightLineOfLength,\n} from \"../arrayUtilities\";\n\nimport random from \"./random\";\n\nconst WINNING_LENGTH = 5;\nconst OWN_ALIGNMENT = true;\nconst ADV_ALIGNMENT = false;\nconst ONE_BOUNDED = 1;\nconst UNBOUNDED = 2;\nconst NO_MATCH = -1;\n\nconst DEBUG = false;\n/**\n * Alert when DEBUG is true\n * @param {*} message\n */\nfunction debugAlert(message) {\n    if (DEBUG) {\n        alert(message);\n    }\n}\n\n/**\n * Smart Bob, first generation \"IA\"\n * @param {*} grid\n * @param {*} side\n * @param {*} ownSymbol\n */\nexport default function smartBobNextMove(grid, side, ownSymbol) {\n    const total = [hasUnBoundedAlignment, hasOneBoundedAlignment];\n\n    // IA has alignment of 4 and we can align a other one => win\n    var r = checkPredict(total, 4, 4, grid, side, ownSymbol, OWN_ALIGNMENT);\n    if (r !== -1) {\n        debugAlert(\"0\");\n        return r;\n    }\n\n    // Adversary has alignment of 4\n    r = checkPredict(total, 4, 4, grid, side, ownSymbol, ADV_ALIGNMENT);\n    if (r !== -1) {\n        debugAlert(\"1\");\n        return r;\n    }\n\n    // IA has alignment of 3 unbounded\n    r = checkPredict([hasUnBoundedAlignment], 3, 3, grid, side, ownSymbol, OWN_ALIGNMENT);\n    if (r !== -1) {\n        debugAlert(\"2\");\n        return r;\n    }\n\n    // Adversary has alignment of 3 unbounded\n    r = checkPredict([hasUnBoundedAlignment], 4, 3, grid, side, ownSymbol, ADV_ALIGNMENT);\n    if (r !== -1) {\n        debugAlert(\"3\");\n        return r;\n    }\n\n    // No vital move needed\n\n    // Adversary has alignment of 3  or 2 bounded or one bounded\n    r = checkPredict(total, 3, 2, grid, side, ownSymbol, ADV_ALIGNMENT);\n    if (r !== -1) {\n        debugAlert(\"4\");\n        return r;\n    }\n\n    // IA has alignment of 3 , 2 or 1\n    r = checkPredict(total, 3, 1, grid, side, ownSymbol, OWN_ALIGNMENT);\n    if (r !== -1) {\n        debugAlert(\"5\");\n        return r;\n    }\n    //alert(\"random\");\n    return random(grid, side);\n}\n\n/**\n * Check every given predicates sort by priority order over all grid for a given range of lengths\n * @param {*} predicates\n * @param {*} max - Max length (included)\n * @param {*} min - Min length (included)\n * @param {*} grid\n * @param {*} side\n * @param {*} ownSymbol\n * @param {*} isCheckingOwnCombi - true if searching for own alignment\n *\n * @return a position aligned with the alignment that fullfilled a predicate or -1 if no predicate fullfilled\n */\nfunction checkPredict(predicates, max, min, grid, side, ownSymbol, isCheckingOwnCombi) {\n    let next_pos = 0;\n\n    // Check for the given length range\n    for (let l = max; l >= min; --l) {\n        // For all predicates\n        for (let p = 0; p < predicates.length; ++p) {\n            // Over the whole array\n            for (let i = 0; i < side; ++i) {\n                for (let j = 0; j < side; ++j) {\n                    // If a preidacte is true return next move otherwise return NO_MATCH\n                    next_pos = predicates[p](grid, side, i, j, ownSymbol, l, isCheckingOwnCombi);\n                    if (next_pos !== NO_MATCH) {\n                        return next_pos;\n                    }\n                }\n            }\n        }\n    }\n    return NO_MATCH;\n}\n\n/**\n * Check if there is a one-bounded alignemnt start at (i,j) of given length\n * @param {*} array\n * @param {*} side\n * @param {*} i\n * @param {*} j\n * @param {*} ownSymbol\n * @param {*} length\n * @param {*} isCheckingOwnCombi - true if searching for own alignment\n */\nfunction hasOneBoundedAlignment(array, side, i, j, ownSymbol, length, isCheckingOwnCombi) {\n    return __hasUnBoundedAlignment__(\n        array,\n        side,\n        i,\n        j,\n        ownSymbol,\n        length,\n        isCheckingOwnCombi,\n        ONE_BOUNDED\n    );\n}\n\nconst countFunctionArray = [\n    countRightDownDiagOfLength,\n    countLeftDownDiagOfLength,\n    countDownColumnOfLength,\n    countRightLineOfLength,\n];\n\n/**\n * Check if there is a unbounded alignemnt start at (i,j) of given length\n * @param {*} array\n * @param {*} side\n * @param {*} i\n * @param {*} j\n * @param {*} ownSymbol\n * @param {*} length\n * @param {*} isCheckingOwnCombi - true if searching for own alignment\n */\nfunction hasUnBoundedAlignment(array, side, i, j, ownSymbol, length, isCheckingOwnCombi) {\n    return __hasUnBoundedAlignment__(\n        array,\n        side,\n        i,\n        j,\n        ownSymbol,\n        length,\n        isCheckingOwnCombi,\n        UNBOUNDED\n    );\n}\n\n// Helper function for hasOneBoundedCombin and hasUnBoundedCombin\nfunction __hasUnBoundedAlignment__(\n    array,\n    side,\n    i,\n    j,\n    ownSymbol,\n    length,\n    isCheckingOwnCombi,\n    numberOfUnboundedSide\n) {\n    const FIRST_BOUND = 0;\n    const SECOND_BOUND = 1;\n\n    for (let alignIdx = 0; alignIdx < countFunctionArray.length; ++alignIdx) {\n        // Compute number of aligned symbols starting at pos (i,j)\n        const size = countFunctionArray[alignIdx](array, side, i, j, WINNING_LENGTH);\n\n        // If it is currently checking for this number of symbols\n        var symbol = null;\n        if (size === length) {\n            symbol = getElem(array, side, i, j);\n        }\n\n        // If symbol match what we are currently looking for\n        if (\n            symbol != null &&\n            ((symbol !== ownSymbol && !isCheckingOwnCombi) ||\n                (symbol === ownSymbol && isCheckingOwnCombi))\n        ) {\n            const hasFirstBound = isFirstBounded(array, side, i, j, alignIdx);\n            const sizeSecondBound = lengthBeforeSecondBound(array, side, i, j, alignIdx);\n            const hasSecondBound = sizeSecondBound > 0;\n            const sizePotSecBound = -sizeSecondBound;\n\n            const lengthSecBound = hasSecondBound ? sizeSecondBound : sizePotSecBound;\n\n            const posFirstBound = computeBoundPos(\n                i,\n                j,\n                side,\n                lengthSecBound,\n                alignIdx,\n                FIRST_BOUND\n            );\n            const posSecBound = computeBoundPos(i, j, side, lengthSecBound, alignIdx, SECOND_BOUND);\n\n            switch (numberOfUnboundedSide) {\n                case UNBOUNDED:\n                    if (!hasFirstBound && !hasSecondBound) {\n                        if (sizePotSecBound > 0) {\n                            return posSecBound;\n                        } else {\n                            return posFirstBound;\n                        }\n                    }\n                    break;\n                case ONE_BOUNDED:\n                    if (!hasSecondBound && sizePotSecBound > 0) {\n                        return posSecBound;\n                    }\n                    if (!hasFirstBound) {\n                        return posFirstBound;\n                    }\n                    break;\n                default:\n                    throw new Error(\n                        \"Bad parameter: numberOfUnboundedSide \" +\n                            numberOfUnboundedSide +\n                            \" should be 1 or 2\"\n                    );\n            }\n        }\n    }\n\n    return NO_MATCH;\n}\n\n/**\n * Return true if the given alignment is first bounded\n * Here are the first bound represented by \"b\"\n * |--0--|--1--|--2--|--3--|\n * |-----|-----|-----|-----|\n * |-b---|---b-|-b---|-bxx-|\n * |--x--|--x--|-x---|-----|\n * |---x-|-x---|-x---|-----|\n * |-----|-----|-----|-----|\n * @param {*} grid\n * @param {*} side\n * @param {*} i\n * @param {*} j\n * @param {*} alignmentNumber\n */\nfunction isFirstBounded(grid, side, i, j, alignmentNumber) {\n    const bounds = computeBounds(i, j, 0); // Length doesn't matter for first bound\n    const i_1 = bounds[alignmentNumber][0][0];\n    const j_1 = bounds[alignmentNumber][0][1];\n    if (!isInBound(side, i_1, j_1)) {\n        return true;\n    }\n    const elem = getElem(grid, side, i_1, j_1);\n    return elem != null;\n}\n\n/**\n * Return the distance to second bound if the alignment is second bounded\n * Return the to distance to the first place to second bound the alignemt if the alignment is not second bounded (in minus)\n * Example: |------| with(1,1) will return -2 because there is a place for second bound at distance 2\n *          |-xx-x-|\n * Here are an example of second bounds represented by \"b\"\n * |--0--|--1--|--2--|--3--|\n * |-----|-----|-----|-----|\n * |-x---|---x-|-x---|-xxb-|\n * |--x--|--x--|-x---|-----|\n * |---b-|-b---|-b---|-----|\n * |-----|-----|-----|-----|\n * @param {*} grid\n * @param {*} side\n * @param {*} i\n * @param {*} j\n * @param {*} alignmentNumber\n */\nfunction lengthBeforeSecondBound(grid, side, i, j, alignmentNumber) {\n    var placeForSecondBound = 0;\n    for (let length = 1; length < WINNING_LENGTH; length++) {\n        const bounds = computeBounds(i, j, length);\n        const i_2 = bounds[alignmentNumber][1][0];\n        const j_2 = bounds[alignmentNumber][1][1];\n\n        // Blocked by the bound of the grid\n        if (!isInBound(side, i_2, j_2)) {\n            return length;\n        }\n        const elem = getElem(grid, side, i_2, j_2);\n        // If there is a cell not null and filled with an other symbol => blocked\n        if (elem !== null && elem !== getElem(grid, side, i, j)) {\n            return length;\n        } else {\n            // Keep in mind the first empty space\n            if (elem === null && placeForSecondBound === 0) {\n                placeForSecondBound = length;\n            }\n        }\n    }\n    return -placeForSecondBound;\n}\n\n/**\n * Compute position in array of bound specified bound\n * @param {*} i\n * @param {*} j\n * @param {*} side\n * @param {*} length\n * @param {*} alignmentNumber\n * @param {*} boundNumber\n */\nfunction computeBoundPos(i, j, side, length, alignmentNumber, boundNumber) {\n    const bounds = computeBounds(i, j, length);\n    const i_1 = bounds[alignmentNumber][boundNumber][0];\n    const j_1 = bounds[alignmentNumber][boundNumber][1];\n    return Number(i_1 * side) + Number(j_1);\n}\n\n/**\n * Compute bounds for all 4 alignemnts for the given length\n * @param {*} i\n * @param {*} j\n * @param {*} length\n */\nfunction computeBounds(i, j, length) {\n    const tab = [\n        [\n            // Right down diag\n            [[i - 1], [j - 1]],\n            [[i + length], [j + length]],\n        ],\n        [\n            // Left down diag\n            [[i - 1], [j + 1]],\n            [[i + length], [j - length]],\n        ],\n        [\n            // Down column\n            [[i - 1], [j]],\n            [[i + length], [j]],\n        ],\n        [\n            // Right line\n            [[i], [j - 1]],\n            [[i], [j + length]],\n        ],\n    ];\n    return tab;\n}\n","/**\n * Player playing randomly on the grid\n * @param {*} grid\n * @param {*} side\n */\nexport default function random(grid, side) {\n    let i = 0;\n    let j = 0;\n    let result = 0;\n    do {\n        i = Math.floor(Math.random() * (side - 1));\n        j = Math.floor(Math.random() * (side - 1));\n        result = Number(i * side) + Number(j);\n    } while (grid[result] != null);\n\n    return result;\n}\n","import React, { useEffect, useState } from \"react\";\nimport \"./style.css\";\n\nimport Grid from \"../Grid\";\nimport GameSettings from \"../GameSettings\";\nimport nextMoveIA from \"./IA\";\nimport { calculateWinner } from \"./arrayUtilities\";\nexport default function Game() {\n    const MIN_SIDE = 5;\n    const MAX_SIDE = 25;\n    const WINNING_ALIGNMENT = 5;\n\n    const [side, setSide] = useState(15);\n    const [array, setArray] = useState(Array((side - 1) * (side - 1)).fill(null));\n\n    const [isCrossNext, setIsCrossNext] = useState(false);\n    const [status, setStatus] = useState(\"Press start to play !\");\n    const [isFinish, setIsFinish] = useState(true);\n\n    /**\n     * Handle the click of a player on the board\n     * @param {*} i - position clicked\n     */\n    const handleClick = (i) => {\n        if (!isFinish && array[i] == null) {\n            const newArray = array.slice();\n            newArray[i] = isCrossNext ? \"X\" : \"O\";\n            setArray(newArray);\n            setIsCrossNext(!isCrossNext);\n        }\n    };\n\n    /**\n     * Handle when the user click start button\n     * @param {*} side\n     * @param {*} firstPlayer\n     */\n    const handleSubmit = (side, firstPlayer) => {\n        setIsCrossNext(firstPlayer === \"X\");\n        const grid = Array((side - 1) * (side - 1)).fill(null);\n        setArray(grid);\n        setIsFinish(false);\n        setSide(side);\n    };\n\n    /**\n     * Play a round check for winner and make IA play at it's turn\n     */\n    function playRound() {\n        if (!isFinish) {\n            const winner = calculateWinner(array, side, WINNING_ALIGNMENT);\n            if (winner != null) {\n                setStatus(\"Winner is \" + winner + \" !\");\n                setIsFinish(true);\n            } else {\n                setStatus(\"Next player is \" + (isCrossNext ? \"X\" : \"O\"));\n\n                if (!isCrossNext) {\n                    const pos = nextMoveIA(array, side, \"O\");\n                    handleClick(pos);\n                }\n            }\n        }\n    }\n\n    useEffect(() => {\n        playRound();\n    });\n\n    return (\n        <div className=\"game-container\">\n            <div className=\"settings-container\">\n                <GameSettings handleSubmit={handleSubmit} minSide={MIN_SIDE} maxSide={MAX_SIDE} />\n            </div>\n            <div className=\"grid-container\">\n                {status}\n                <Grid array={array} side={side} handleClick={handleClick} />\n            </div>\n            <div className=\"text-container\">\n                {\"Rules:\"}\n                <br></br>\n                {\"Be the first one to align 5 symbols\"}\n                <br></br>\n                <br></br>\n                {\"Context:\"}\n                <br></br>\n                {\n                    \"This was my favorite game to keep me busy during boring class in high school. Hey kids, don't be like me, be focused at school, it's important. \"\n                }\n            </div>\n        </div>\n    );\n}\n","import smartBobNextMove from \"./smartBob\";\nimport random from \"./random\";\n\n/**\n * Return next move of the selected IA\n * @param {*} grid\n * @param {*} side\n * @param {*} ownSymbol\n */\nexport default function nextMoveIA(grid, side, ownSymbol) {\n    //return random(grid, side);\n    return smartBobNextMove(grid, side, ownSymbol);\n}\n","import \"./App.css\";\nimport Game from \"./components/Game\";\n\nfunction App() {\n    return (\n        <div className=\"App\">\n            <header className=\"App-header\">\n                <Game />\n            </header>\n        </div>\n    );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}